!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).geodesy={})}(this,function(t){"use strict";let e=" ";class i{static get separator(){return e}static set separator(t){e=t}static parse(t){if(!isNaN(parseFloat(t))&&isFinite(t))return Number(t);const e=String(t).trim().replace(/^-/,"").replace(/[NSEW]$/i,"").split(/[^0-9.,]+/);if(""==e[e.length-1]&&e.splice(e.length-1),""==e)return NaN;let i=null;switch(e.length){case 3:i=e[0]/1+e[1]/60+e[2]/3600;break;case 2:i=e[0]/1+e[1]/60;break;case 1:i=e[0];break;default:return NaN}return/^-|[WS]$/i.test(t.trim())&&(i=-i),Number(i)}static toDms(t,e="d",r=void 0){if(isNaN(t))return null;if("string"==typeof t&&""==t.trim())return null;if("boolean"==typeof t)return null;if(t==1/0)return null;if(null==t)return null;if(void 0===r)switch(e){case"d":case"deg":r=4;break;case"dm":case"deg+min":r=2;break;case"dms":case"deg+min+sec":r=0;break;default:e="d",r=4}t=Math.abs(t);let n=null,a=null,s=null,o=null;switch(e){default:case"d":case"deg":a=t.toFixed(r),a<100&&(a="0"+a),a<10&&(a="0"+a),n=a+"°";break;case"dm":case"deg+min":a=Math.floor(t),s=(60*t%60).toFixed(r),60==s&&(s=(0).toFixed(r),a++),a=("000"+a).slice(-3),s<10&&(s="0"+s),n=a+"°"+i.separator+s+"′";break;case"dms":case"deg+min+sec":a=Math.floor(t),s=Math.floor(3600*t/60)%60,o=(3600*t%60).toFixed(r),60==o&&(o=(0).toFixed(r),s++),60==s&&(s=0,a++),a=("000"+a).slice(-3),s=("00"+s).slice(-2),o<10&&(o="0"+o),n=a+"°"+i.separator+s+"′"+i.separator+o+"″"}return n}static toLat(t,e,r){const n=i.toDms(i.wrap90(t),e,r);return null===n?"–":n.slice(1)+i.separator+(t<0?"S":"N")}static toLon(t,e,r){const n=i.toDms(i.wrap180(t),e,r);return null===n?"–":n+i.separator+(t<0?"W":"E")}static toBrng(t,e,r){const n=i.toDms(i.wrap360(t),e,r);return null===n?"–":n.replace("360","0")}static fromLocale(t){const e=123456.789.toLocaleString(),i={thousands:e.slice(3,4),decimal:e.slice(7,8)};return t.replace(i.thousands,"⁜").replace(i.decimal,".").replace("⁜",",")}static toLocale(t){const e=123456.789.toLocaleString(),i={thousands:e.slice(3,4),decimal:e.slice(7,8)};return t.replace(/,([0-9])/,"⁜$1").replace(".",i.decimal).replace("⁜",i.thousands)}static compassPoint(t,e=3){if(![1,2,3].includes(Number(e)))throw new RangeError(`invalid precision ‘${e}’`);t=i.wrap360(t);const r=4*2**(e-1);return["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"][Math.round(t*r/360)%r*16/r]}static wrap90(t){if(-90<=t&&t<=90)return t;const e=t,i=360;return 1*Math.abs(((e-90)%i+i)%i-180)-90}static wrap180(t){if(-180<=t&&t<=180)return t;const e=360;return((360*t/e-180)%e+e)%e-180}static wrap360(t){if(0<=t&&t<360)return t;const e=360;return(360*t/e%e+e)%e}}Number.prototype.toRadians=function(){return this*Math.PI/180},Number.prototype.toDegrees=function(){return 180*this/Math.PI};class r{constructor(t,e,i){if(isNaN(t)||isNaN(e)||isNaN(i))throw new TypeError(`invalid vector [${t},${e},${i}]`);this.x=Number(t),this.y=Number(e),this.z=Number(i)}get length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}plus(t){if(!(t instanceof r))throw new TypeError("v is not Vector3d object");return new r(this.x+t.x,this.y+t.y,this.z+t.z)}minus(t){if(!(t instanceof r))throw new TypeError("v is not Vector3d object");return new r(this.x-t.x,this.y-t.y,this.z-t.z)}times(t){if(isNaN(t))throw new TypeError(`invalid scalar value ‘${t}’`);return new r(this.x*t,this.y*t,this.z*t)}dividedBy(t){if(isNaN(t))throw new TypeError(`invalid scalar value ‘${t}’`);return new r(this.x/t,this.y/t,this.z/t)}dot(t){if(!(t instanceof r))throw new TypeError("v is not Vector3d object");return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){if(!(t instanceof r))throw new TypeError("v is not Vector3d object");const e=this.y*t.z-this.z*t.y,i=this.z*t.x-this.x*t.z,n=this.x*t.y-this.y*t.x;return new r(e,i,n)}negate(){return new r(-this.x,-this.y,-this.z)}unit(){const t=this.length;if(1==t)return this;if(0==t)return this;const e=this.x/t,i=this.y/t,n=this.z/t;return new r(e,i,n)}angleTo(t,e=void 0){if(!(t instanceof r))throw new TypeError("v is not Vector3d object");if(!(e instanceof r||null==e))throw new TypeError("n is not Vector3d object");const i=null==e||this.cross(t).dot(e)>=0?1:-1,n=this.cross(t).length*i,a=this.dot(t);return Math.atan2(n,a)}rotateAround(t,e){if(!(t instanceof r))throw new TypeError("axis is not Vector3d object");const i=e.toRadians(),n=this.unit(),a=t.unit(),s=Math.sin(i),o=Math.cos(i),h=1-o,l=a.x,u=a.y,c=a.z,d=[[h*l*l+o,h*l*u-s*c,h*l*c+s*u],[h*l*u+s*c,h*u*u+o,h*u*c-s*l],[h*l*c-s*u,h*u*c+s*l,h*c*c+o]],p=[d[0][0]*n.x+d[0][1]*n.y+d[0][2]*n.z,d[1][0]*n.x+d[1][1]*n.y+d[1][2]*n.z,d[2][0]*n.x+d[2][1]*n.y+d[2][2]*n.z];return new r(p[0],p[1],p[2])}toString(t=3){return`[${this.x.toFixed(t)},${this.y.toFixed(t)},${this.z.toFixed(t)}]`}}Number.prototype.toRadians=function(){return this*Math.PI/180},Number.prototype.toDegrees=function(){return 180*this/Math.PI};const n={WGS84:{a:6378137,b:6356752.314245,f:1/298.257223563}},a={WGS84:{ellipsoid:n.WGS84}};Object.freeze(n.WGS84),Object.freeze(a.WGS84);class s{constructor(t,e,r=0){if(isNaN(t)||null==t)throw new TypeError(`invalid lat ‘${t}’`);if(isNaN(e)||null==e)throw new TypeError(`invalid lon ‘${e}’`);if(isNaN(r)||null==r)throw new TypeError(`invalid height ‘${r}’`);this._lat=i.wrap90(Number(t)),this._lon=i.wrap180(Number(e)),this._height=Number(r)}get lat(){return this._lat}get latitude(){return this._lat}set lat(t){if(this._lat=isNaN(t)?i.wrap90(i.parse(t)):i.wrap90(Number(t)),isNaN(this._lat))throw new TypeError(`invalid lat ‘${t}’`)}set latitude(t){if(this._lat=isNaN(t)?i.wrap90(i.parse(t)):i.wrap90(Number(t)),isNaN(this._lat))throw new TypeError(`invalid latitude ‘${t}’`)}get lon(){return this._lon}get lng(){return this._lon}get longitude(){return this._lon}set lon(t){if(this._lon=isNaN(t)?i.wrap180(i.parse(t)):i.wrap180(Number(t)),isNaN(this._lon))throw new TypeError(`invalid lon ‘${t}’`)}set lng(t){if(this._lon=isNaN(t)?i.wrap180(i.parse(t)):i.wrap180(Number(t)),isNaN(this._lon))throw new TypeError(`invalid lng ‘${t}’`)}set longitude(t){if(this._lon=isNaN(t)?i.wrap180(i.parse(t)):i.wrap180(Number(t)),isNaN(this._lon))throw new TypeError(`invalid longitude ‘${t}’`)}get height(){return this._height}set height(t){if(this._height=Number(t),isNaN(this._height))throw new TypeError(`invalid height ‘${t}’`)}get datum(){return this._datum}set datum(t){this._datum=t}static get ellipsoids(){return n}static get datums(){return a}static parse(...t){if(0==t.length)throw new TypeError("invalid (empty) point");let e,r,n;if("object"==typeof t[0]&&(1==t.length||!isNaN(parseFloat(t[1])))){const a=t[0];if("Point"==a.type&&Array.isArray(a.coordinates)?([r,e,n]=a.coordinates,n=n||0):(null!=a.latitude&&(e=a.latitude),null!=a.lat&&(e=a.lat),null!=a.longitude&&(r=a.longitude),null!=a.lng&&(r=a.lng),null!=a.lon&&(r=a.lon),null!=a.height&&(n=a.height),e=i.wrap90(i.parse(e)),r=i.wrap180(i.parse(r))),null!=t[1]&&(n=t[1]),isNaN(e)||isNaN(r))throw new TypeError(`invalid point ‘${JSON.stringify(t[0])}’`)}if("string"==typeof t[0]&&2==t[0].split(",").length&&([e,r]=t[0].split(","),e=i.wrap90(i.parse(e)),r=i.wrap180(i.parse(r)),n=t[1]||0,isNaN(e)||isNaN(r)))throw new TypeError(`invalid point ‘${t[0]}’`);if(null==e&&null==r&&([e,r]=t,e=i.wrap90(i.parse(e)),r=i.wrap180(i.parse(r)),n=t[2]||0,isNaN(e)||isNaN(r)))throw new TypeError(`invalid point ‘${t.toString()}’`);return new this(e,r,n)}toCartesian(){const t=this.datum?this.datum.ellipsoid:this.referenceFrame?this.referenceFrame.ellipsoid:n.WGS84,e=this.lat.toRadians(),i=this.lon.toRadians(),r=this.height,{a:a,f:s}=t,h=Math.sin(e),l=Math.cos(e),u=Math.sin(i),c=Math.cos(i),d=2*s-s*s,p=a/Math.sqrt(1-d*h*h);return new o((p+r)*l*c,(p+r)*l*u,(p*(1-d)+r)*h)}equals(t){if(!(t instanceof s))throw new TypeError(`invalid point ‘${t}’`);return!(Math.abs(this.lat-t.lat)>Number.EPSILON)&&(!(Math.abs(this.lon-t.lon)>Number.EPSILON)&&(!(Math.abs(this.height-t.height)>Number.EPSILON)&&(this.datum==t.datum&&(this.referenceFrame==t.referenceFrame&&this.epoch==t.epoch))))}toString(t="d",e=void 0,r=null){if(!["d","dm","dms","n"].includes(t))throw new RangeError(`invalid format ‘${t}’`);const n=(this.height>=0?" +":" ")+this.height.toFixed(r)+"m";if("n"==t){null==e&&(e=4);return`${this.lat.toFixed(e)}, ${this.lon.toFixed(e)}${null==r?"":n}`}return`${i.toLat(this.lat,t,e)}, ${i.toLon(this.lon,t,e)}${null==r?"":n}`}}class o extends r{constructor(t,e,i){super(t,e,i)}toLatLon(t=n.WGS84){if(!t||!t.a)throw new TypeError(`invalid ellipsoid ‘${t}’`);const{x:e,y:i,z:r}=this,{a:a,b:o,f:h}=t,l=2*h-h*h,u=l/(1-l),c=Math.sqrt(e*e+i*i),d=o*r/(a*c)*(1+u*o/Math.sqrt(c*c+r*r)),p=d/Math.sqrt(1+d*d),N=p/d,f=isNaN(N)?0:Math.atan2(r+u*o*p*p*p,c-l*a*N*N*N),w=Math.atan2(i,e),g=Math.sin(f),m=c*Math.cos(f)+r*g-a*a/(a/Math.sqrt(1-l*g*g));return new s(f.toDegrees(),w.toDegrees(),m)}toString(t=0){return`[${this.x.toFixed(t)},${this.y.toFixed(t)},${this.z.toFixed(t)}]`}}const h=Math.PI,l=Number.EPSILON;class u extends s{distanceTo(t){try{const e=this.inverse(t).distance;return Number(e.toFixed(3))}catch(t){if(t instanceof EvalError)return NaN;throw t}}initialBearingTo(t){try{const e=this.inverse(t).initialBearing;return Number(e.toFixed(7))}catch(t){if(t instanceof EvalError)return NaN;throw t}}finalBearingTo(t){try{const e=this.inverse(t).finalBearing;return Number(e.toFixed(7))}catch(t){if(t instanceof EvalError)return NaN;throw t}}destinationPoint(t,e){return this.direct(Number(t),Number(e)).point}finalBearingOn(t,e){const i=this.direct(Number(t),Number(e)).finalBearing;return Number(i.toFixed(7))}intermediatePointTo(t,e){if(0==e)return this;if(1==e)return t;const i=this.inverse(t),r=i.distance,n=i.initialBearing;return isNaN(n)?this:this.destinationPoint(r*e,n)}direct(t,e){if(isNaN(t))throw new TypeError(`invalid distance ${t}`);if(0==t)return{point:this,finalBearing:NaN,iterations:0};if(isNaN(e))throw new TypeError(`invalid bearing ${e}`);if(0!=this.height)throw new RangeError("point must be on the surface of the ellipsoid");const r=this.lat.toRadians(),n=this.lon.toRadians(),a=Number(e).toRadians(),o=Number(t),h=this.datum?this.datum.ellipsoid:s.ellipsoids.WGS84,{a:l,b:c,f:d}=h,p=Math.sin(a),N=Math.cos(a),f=(1-d)*Math.tan(r),w=1/Math.sqrt(1+f*f),g=f*w,m=Math.atan2(f,N),b=w*p,y=1-b*b,M=y*(l*l-c*c)/(c*c),E=1+M/16384*(4096+M*(M*(320-175*M)-768)),v=M/1024*(256+M*(M*(74-47*M)-128));let x=o/(c*E),$=null,T=null,S=null,z=null,F=0;do{S=Math.cos(2*m+x),$=Math.sin(x),T=Math.cos(x);z=x,x=o/(c*E)+v*$*(S+v/4*(T*(2*S*S-1)-v/6*S*(4*$*$-3)*(4*S*S-3)))}while(Math.abs(x-z)>1e-12&&++F<100);if(F>=100)throw new EvalError("Vincenty formula failed to converge");const _=g*$-w*T*N,W=Math.atan2(g*T+w*$*N,(1-d)*Math.sqrt(b*b+_*_)),L=d/16*y*(4+d*(4-3*y)),R=n+(Math.atan2($*p,w*T-g*$*N)-(1-L)*d*b*(x+L*$*(S+L*T*(2*S*S-1)))),P=Math.atan2(b,-_);return{point:new u(W.toDegrees(),R.toDegrees(),0,this.datum),finalBearing:i.wrap360(P.toDegrees()),iterations:F}}inverse(t){if(!(t instanceof s))throw new TypeError(`invalid point ‘${t}’`);if(0!=this.height||0!=t.height)throw new RangeError("point must be on the surface of the ellipsoid");const e=t,r=this.lat.toRadians(),n=this.lon.toRadians(),a=e.lat.toRadians(),o=e.lon.toRadians(),u=this.datum?this.datum.ellipsoid:s.ellipsoids.WGS84,{a:c,b:d,f:p}=u,N=o-n,f=(1-p)*Math.tan(r),w=1/Math.sqrt(1+f*f),g=f*w,m=(1-p)*Math.tan(a),b=1/Math.sqrt(1+m*m),y=m*b,M=Math.abs(N)>h/2||Math.abs(a-r)>h/2;let E=N,v=null,x=null,$=M?h:0,T=0,S=M?-1:1,z=null,F=1,_=1,W=null,L=0;do{if(v=Math.sin(E),x=Math.cos(E),z=(b*v)**2+(w*y-g*b*x)**2,Math.abs(z)<1e-24)break;T=Math.sqrt(z),S=g*y+w*b*x,$=Math.atan2(T,S);const t=w*b*v/T;_=1-t*t,F=0!=_?S-2*g*y/_:0;const e=p/16*_*(4+p*(4-3*_));W=E,E=N+(1-e)*p*t*($+e*T*(F+e*S*(2*F*F-1)));if((M?Math.abs(E)-h:Math.abs(E))>h)throw new EvalError("λ > π")}while(Math.abs(E-W)>1e-12&&++L<1e3);if(L>=1e3)throw new EvalError("Vincenty formula failed to converge");const R=_*(c*c-d*d)/(d*d),P=R/1024*(256+R*(R*(74-47*R)-128)),B=d*(1+R/16384*(4096+R*(R*(320-175*R)-768)))*($-P*T*(F+P/4*(S*(2*F*F-1)-P/6*F*(4*T*T-3)*(4*F*F-3)))),D=Math.abs(z)<l?0:Math.atan2(b*v,w*y-g*b*x),j=Math.abs(z)<l?h:Math.atan2(w*v,-g*b+w*y*x);return{distance:B,initialBearing:Math.abs(B)<l?NaN:i.wrap360(D.toDegrees()),finalBearing:Math.abs(B)<l?NaN:i.wrap360(j.toDegrees()),iterations:L}}}t.LatLon=u,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=geodesy-custom.js.map
